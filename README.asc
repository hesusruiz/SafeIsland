= SafeIsland
:encoding: utf-8
:lang: en
:toc: left
:author: Jesus Ruiz
:email: hesus.ruiz@gmail.com
:revnumber: 0.3
:revdate: 17-01-2021
:numbered:
:imagesdir: images
:icons: font
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
:3dots: ...

(Version: {revnumber}, Version Date: {revdate})

This is a generic digital credential system which is designed to be secure, privacy-preserving, scalable, performant and robust. It is designed specifically for some important use cases where physical, on-person verification of identity of holder is needed and where normal W3C Verifiable Credential flows are not fully suitable as they are normally designed currently.

== Requirements

The requirements of the system are basically the same as described in the section https://www.w3.org/TR/vc-data-model/#use-cases-and-requirements[Use Cases and Requirements] of the W3C Verifiable Credentials Data Model, with some modifications to adapt them to the specific requirements of this use case.

One major difference arises from the fact that in our case the interactions Issuer-Holder and Holder-Verifier are in-person instead of purely online. That is:

* The Issuer is an authorized health entity performing a Covid test to the Citizen (the Holder).
* The Verifier is typically an authorized legal person checking in-person that the Citizen performed a Covid test recently and the result was negative. For example:
** When entering a country, authorized personnel check standard travel documents (e.g. passport) and the digital Verifiable Credential with the Covid test result.
** When registering in the hotel, the hotel employee checks the standard travel documents and the digital credential

In other words, in this use case the identity of the Holder (Citizen) is checked in-person with standard documents. The Verifiable Credential is used to provide an efficient and tamper-resistant proof that the Citizen performed the Covid test as required legally.

For easier reference, some of the requirements described in https://www.w3.org/TR/vc-data-model/#use-cases-and-requirements[W3C Verifiable Credentials Data Model] are replicated here, noting the differences when they exist.

* Verifiable credentials represent statements made by an issuer in a tamper-evident and privacy-respecting manner.

* Issuers can issue verifiable credentials about any subject.

* Issuers are authorized health institutions, so we require registration of those entities.

* Legal persons acting as verifiers should be registered in the system.

* Natural persons acting as verifier requires neither registration nor approval by any authority, as the trust involved is bilateral between parties. This assumes that the Citizen sends them the credential voluntarily. This is different from the above requirement, when proving the negative result of a Covid test is a legal requirement to enter the country.

* Verifiable presentations allow any verifier to verify the authenticity of verifiable credentials from any issuer.

* Holders can receive verifiable credentials from anyone.

* Holders can interact with any issuer and any verifier through any user agent.

* Holders can share verifiable presentations, which can then be verified without revealing the identity of the verifier to the issuer.

* Holders can store verifiable credentials in any location, without affecting their verifiability and without the issuer knowing anything about where they are stored or when they are accessed.

* Holders can present verifiable presentations to any verifier without affecting authenticity of the claims and without revealing that action to the issuer.

* A verifier can verify verifiable presentations from any holder, containing proofs of claims from any issuer.

* Verification should not depend on direct interactions between issuers and verifiers.

* Verification should not reveal the identity of the verifier to any issuer.

* Issuers can issue verifiable credentials that support selective disclosure.

* If a single verifiable credential supports selective disclosure, then holders can present proofs of claims without revealing the entire verifiable credential.

* Issuers can issue verifiable credentials with an expiration date that can not be tampered.

* Verifiable credentials and verifiable presentations have to be serializable in one or more machine-readable data formats. The process of serialization and/or de-serialization has to be deterministic, bi-directional, and lossless.

* The data model and serialization must be extendable with minimal coordination.

* The issuance of the VC can be "on the spot" and while the Citizen is physically present. That is, the Citizen does not have to be pre-registered in any system or be a customer of the Issuer Entity before the issuance of the VC starts. For example, the Citizen can take a Covid19 test in some place and the Issuer Entity can issue the credential during the process, without the Citizen having any previous relation with the Issuer Entity.

* The Issuer Entity is accountable for the veracity of the fact that is attested about the Citizen. 

* No personal data should ever be stored in the blockchain. Any personal data management should be performed off-chain by well-identified legal entities that have to comply with all applicable regulations, including GDPR.

* No digital identities of natural persons should ever be registered in the blockchain. This requirement is related to the one above, but is not exactly the same. This requirement says that no Digital Identity of a natural person should be registered in the blockchain using any mechanism *even if the mechanism claims that the data stored is not personal data*. This requirement tries to avoid any risk related to the blockchain and personal data, especially when a proper PIA (Privacy Impact Assessment) has not been performed, and there is not yet a general consensus among the data protection agencies in the EU about the subject.

== General description of the system

=== Main components

---
.Components of the system
image::SafeIsland_Components.png[]
---

The main components are the following:

Issuer Entity:: The juridical person that digitally signs and issues a credential to the User. The Issuer Entity employs or subcontracts the actual people performing the process, called Issuer Operator in the diagram. The Issuer Entity assumes full responsibility for the legal implications of the issueance process, especially GDPR compliance. The Issuer Entity acts as a Data Controller with respect to the Personal Information collected from the Citizen when the certification is issued.

- *Issuer Operator* The natural person that is employed/subcontracted by the Issuer Entity to actually drive the process of issuing the credential on behalf of the Issuer Entity.

- *Issuer Operator App* This is the application used by the natural person that drives the issuance of the credential. The application allows the operator to enter the details of the user and of the credential and issues the credential to the user on behalf of the Issuer Entity. It is the responsibility of the Issuer Entity to ensure that the Operator performs the process in the right way.

Citizen:: This is the natural person that receives a credential and may present it when needed.

- *Citizen mobile WebApp* This is the application used by the end user to manage the credentials. The reference implementation is not a native application but rather a PWA (Progressive Web App), which can be used either as a normal web app (without installation) or it can be installed and used in a very similar way to a native mobile app. The characteristics of this app are explained later.

Verifier Entity:: A juridical person that verifies the credential. In the process of verification, the Verifier Entity receives personal data from the Citizen. The Verifier Entity is responsible for compliance of all applicable regulations, including GDPR.

- *Verifier Operator* A natural person that verifies the credential. It is important to distinguish between natural and juridical persons in the verification process because the flows may be different as the regulatory implications may be different. The diagram does not explicitly mention the Verifier Person, but it will be described in detail later in the document.

- *Verifier App* The application used to verify the credential presented by the user. The reference application can be used either by an employee of a Verifier Entity or by an individual natural person, as explained later.

Public-Permissioned blockchain network:: This is a general-purpose blockchain network which is used to implement the Trust Framework allowing the efficient and secure verification of credentials. It is never used to store personal information. Personal information management is the responsibility of the legal entities Issuer Entity and Verifier Entity, and they are responsible for compliance to applicable regulations, especially GDPR. There may be more than one blockchain network, and the system is very interoperable across networks. The specific interoperability features are describer in a specific section later in this document.

=== Main credential flow

---
.Main credential flow
image::RapidTest_Architecture-Operation.png[]
---

(1) Verification of User and Credential issuance::
+
The Issuer Operator identifies the User (in the same way as an airline employee identifies passengers before boarding a plane) and uses her mobile app to enter the details of the User. In the initial implementation of the system the operator has also to enter manually the details of the Credential to be issued. It is the responsibility of the Issuer Operator (and ultimately of the Issuer Entity) to ensure the veracity of both the User details and the Credential details. This is a critical point in the system, as the level of trust in the credentials will depend on the level of trust of the issuance process.

(2) Sending the Credential to the Citizen::
+
The Credential is sent to the User. There are several possible flows, using different channels (email, QR, etc.). The main one is using QR codes and is the following:

1. The Issuer Operator displays the credential for the User in her mobile phone screen, in a QR format. More detaisl about the specific QR format later.
2. The User scans the QR using her mobile web app.
3. The mobile web app of the User gets the Credential and stores it in the storage of the mobile device.

(3) Store the Credential::
The Credential is stored in the mobile phone of the User. In the reference implementation it is stored in the IndexedDB local database. More than one credential can be stored in the mobile. A Citizen could for example store credentials of other persons of the family when traveling, or a history track of credentials received during a vacation. More details are given later in this document.

(4) Present the Credential::
When the Citizen has to prove something, she sends the Credential to the Verifier. As before, there are several possible flows, the main one using QR codes:
+
1. The User display the Credential in her mobile phone in QR format.
2. The Verifier scans the QR from the User mobile screen
3. The mobile app from the Verifier receives the Credential and verifies it.

(5) Verify the Credential using the Trust Framework in the blockchain::
The Verifier mobile app verifies formally the Credential with the signature, and then checks that the signature of the Credential corresponds to an authorized Issuer Entity registered in the Trust Framework in the blockchain. The verification process is essentially the one described in the W3C VC specifications.


== The Trust Framework: bootstrapping the system

Before the issuance of credentials can take place, the system has to be bootstrapped and setup. There are two processes that have to be performed:

1. A One-time process at the beginning of the whole system: involves things like deploying Smart Contracts and initializing them with the parameters of the system.

2. A process for the onboarding of each new Issuer Entity and Verifier Entity. This process is basically generating and registering n the blockchain the Identity of the entity entering the system.

=== Public-Permissioned blockchain network: Alastria Red T

The system requires at least one https://github.com/hesusruiz/PublicPermissionedBlockchain[Public-Permissioned] blockchain network as https://github.com/alastria/alastria-node[Alastria Red T]. The network should be trusted, efficient, publicly available and compliant with all applicable regulations.

The system is designed to be easily interoperable with other Public-Permissioned blockchain networks, like LACChain or EBSI. This is described in detail in the appropriate section of this document.

=== Information in the blockchain and Personal Identifiable Information (PII)

*No personal information is ever recorded on the blockchain*. The blockchain is only used  to register the identities of the legal persons involved in the system. The information recorded for businesses and organizations includes:

- Public identification information of the legal person in the current regulatory environment, like VAT number, LEI (https://www.gleif.org[Legal Entity Identifier]), or any legally accepted identification in the countries participating in the system.

- Some commercial information, like the web site

- The public key used to verify the Verifiable Credentials digitally signed by the legal entity

The diagram below shows the registration of a new Issuer Entity in the blockchain. There are two types of legal persons registered in the blockchain:

1. *Issuer Entity*: a legal person has to be properly registered before it can issue any credential that can be verified by other actors in the system.

2. *Verifier Entity*: a legal person that receives and verifies credentials from natural persons has to be registered in the blockchain. When the legal person receives the credential (which includes personal data), this fact is registered in order to enhance auditability of the system later. This registration is performed in a privacy-preserving and scalable way. The process is described in detail later in this document. Natural persons can also verify credentials, but the verification process is different in order to avoid pre-registration of natural persons. This is described in detail later.

---
.Trusted Registry of Legal Entities in the blockchain
image::RapidTest_Architecture.png[]
---

=== Trust Framework: trusted registration process of legal entities

---
.The Trust Framework in the blockchain
image::SafeIsland_TrustFramework.png[]
---


== Credential flows

=== Credential Issuance

The figure below describes the interaction flows between the Issuer and the Citizen. Here the term Issuer includes the mobile application of the Issuer Operator and the associated backend system of the Issuer Entity.

The main interaction consists on the transmission of the Verifiable Credential from the Issuer to the mobile of the Citizen. The transmission is initiated with a QR, but given that the amount of data to be transmitted is too big for including it in a QR, the mechanism used splits the VC data into two parts: PII and non-PII data. The PII data is small and is transmitted directly via the QR. The non-PII data is bigger and is transmitted with the help of an intermediary: the Secure Messaging Server.

The flows and the APIs used are described in detail below.

---
.Credential Issuance
image::SafeIsland_CredentialIssuance.png[]
---

The credential issuance process is the following:

*Obtain Informed Consent from the Citizen*

- At the beginning of the interaction, the Citizen has to be identified *in person* by the Issuer Operator, using whatever legally identification mechanisms are required in the country and for the issuance of the credential, for example with National ID, Passport, Drivers License, etc. The Citizen has to provide an explicit informed consent for the provision and specific usage of her personal data, as required by the GDPR. The Issuer Entity becomes the Data Controller, in GDPR terminology. As mentioned before, this process requires physical presence of the Citizen.

*Credential generation*

- The Issuer Operator enters the data of the Citizen in the system, together with the data which will go in the Credential. In the case of a Covid test which was negative, this data will be the result, type of test, date, etc.

- The system stores the information and generates a credential in the standard W3C Verifiable Credential format.

- The system then generates a QR code displayed in the Issuer Operator device that will be scanned by the Citizen to receive the Credential.

- The system uses the standard W3C Verifiable Credential format, and in general the amount of data in those credentials is too big to fit in a single QR. To overcome this limitation, the system uses an efficient and privacy-preserving mechanim:

** The Verifiable Credential is split into two parts: one with the PII information and another one with the non-PII data (the credential data which is exactly the same for all credentials of that type issued to all Citizens). The PII data is in general very small and fits perfectly in a QR.

** The QR is created with the PII and a URL pointing to a location where the non-PII credential data is stored.

This process is described in detail in <<SplitVC>>.

*Citizen receives the Credential*

* The Citizen uses the webapp to scan the QR code displayed by the Issuer Operator

* The Citizen mobile webapp uses the URL in the QR to get the non-PII information (and mostly static), and merges it with the PII information received directly from the QR. The resut is a full Verifiable Credential, including its digital signature.

*Citizen webapp verifies the credential and signature of Issuer*

* The credential is verified as per the standard https://w3c.github.io/vc-imp-guide[W3C Verifiable Credentials Implementation Guidelines].

* The verification includes resolving in the blockchain the identity of the Issuer Entity specified by the Issuer DID in the credential. The Issuer DID is registered in the blockchain and it includes the Public Key used by the Issuer Entity to digitally sign the credential.

* The Citizen mobile webapp uses a Universal Resolver to make this DID resolution and access the blockchain in read mode. The Universal Resolver is described in detail later in this document.

* After verification the credential is stored in the local storage of the Citizen mobile device. The user has also the option to store the credential in encrypted form in one or more of the personal cloud storage systems she has (Google Drive, MS Onedrive, Dorpbox, ...).

=== Credential Verification

The Citizen can send the credential to a Verifier Operator when needed. In the case of a Covid test result, this is typically performed when entering a country via air and the official personnel in the destination airport wants to check that the person entering performed a Covid test recently and that it was negative.

---
.Credential Verification
image::SafeIsland_CredentialPresentation.png[]
---

== Secure Messaging Server (SMS)

The Secure Messaging Server (SMS) is a component that helps in the secure and privacy-perserving transmission of Verifiable Credentials among the participants in the ecosystem. Even though it is general-purpose, this section documents its operation when integrated with the QR mechanism to send and receive credentials. The description is applicable both to when the Issuer sends a credential to the Citizen and also when the Citizen sends a credential to the Verifier. This is the reason why in this description we use the general terms Sender and Receiver to refer to those roles in one interaction.

=== Overall process for sending and receiving credentials

==== Step 1: Split Verifiable Credential in PII and non-PII parts

The first thing that the Sender has to do is to extract and separate the PII data from the full credential. The approach taken is the same as the one used in https://en.wikipedia.org/wiki/Web_template_system[web templating engines] for generating dynamic web pages from the server side.

In our case the static non-PII data is the result of replacing each PII data item in the full credential with the string `[[identifier]]` where identifier is a unique symbol for each different PII data item in the credential. To minimize the size of the PII data in the QR, the identifiers are sequential numbers starting with 1. For example, the first PII data item in the credential is replaced by `[[1]]`, the second with `[[2]]` and so on. If the same PII data item appears more than one time in the credential, the same identifier should be used. Care should be taken not to add or eliminate white space from the original credential, in order to not invalidate the digital signature when reconstructed.

The detailed process to convert a standard Verifiable Credential in JWT format into the non-PII packet to send to the SMS is the following:

1. Extract the header and payload parts from the JWT string.
2. Decode into JSON the payload part of the JWT (the string between the first and second `.` in the full JWT string. Remember that the JWT payload is encoded using https://www.base64url.com/[Base64URL encoding].
3. Replace each PII data item in the decoded payload with the identifiers, as described above. We call this the "non-PII payload".
4. Encode the resulting non-PII payload into a standard JWT payload section (using Base64URL encoding).
5. Build a JSON object (called non-PII object) with the following members:
** header: the header of the JWT, as it was extracted in step 1.
** payload: the non-PII payload, as encoded in step 4.

See <<SplitVC>> for an example of splitting the PII and non-PII parts. 

==== Step 2: Send the static non-PII part to the Secure Messaging Server

The Sender has to choose one of the available Secure Messaging Servers available in the ecosystem. It could be one that the Sender hosts and operates itself, for example if the Sender is an Issuer Entity. But it could be one that is hosted by any other entity in the ecosystem and is trusted by the Sender. The level of trust required is very low, because the information sent is not sensitive and any tampering will be detected when checking the signature, but the Sender must trust that the chosen SMS will not censor the request by rejecting to send it. In any case, such a behaviour is easily detected by the Sender almost in real-time and can start using another server in that case.

The Sender has to write the non-PII object to the chosen SMS using the API /api/write as documented in https://safeisland.hesusruiz.org/docs[]. The call is a POST where the non-PII object is sent in the body of the request.

The reply of the write is the object identifier in the SMS so the Receiver can retrieve the non-PII object. The object identifier has a special structure which is described in detail in the section where the SMS is specified.

==== Step 3: Build and display the QR

The Sender creates a QR with the PII and the URL to retrieve the non-PII object from the SMS. The format of the data included in the QR is the following:

----
URLforReceiver
Signature_of_jwt
first_piece_of_PII
second_piece_of_PII
third_piece_of_PII
...
nth_piece_of_PII
----

With one item per line where each item is left-justified in the line:

* The first line is the concatenation of the SMS address with the object ID returned by the write operation. Example: `https://safeisland.hesusruiz.org/api/read/123456789012345`. When performing a GET operation with this URL, the server will return the non-PII object written previously by the Sender.
* The second item is the signature part of the original JWT, the string after the second dot in the standard JWT representation. It should be sent exactly as it would in a standard JWT transmission, without the dot.
* The following items are the individual pieces of PII. They should appear in increasing sequence number, starting from 1.

This format imposes some restrictions on the possible contents and encoding of each individual PII item. For example, the PII items can not contain newline. But in our case, this format is the most compact and is adequate enough.

==== Step 4: Receive the credential

The Receiver scans and decodes the QR and reconstructs the original Verifiable Credential in JWT format using this process:

* Uses the URL in the first item to receive the non-PII object from the SMS, using an HTTP GET.
* Decodes the payload field of of the non-PII object (using Base64URL encoding).
* Uses the PII items to replace them in the decoded payload field, in a similar way to using a web template system. Essentially, each `[[identifier]]` is replaced with the corresponding PII item.
* Encodes the resulting payload into the standard JWT format (using Base64URL encoding).
* Concatenates the header, payload and signature (the second item in the QR) separated by dots, to obtain a full JWT.

==== Step 5: Verify the credential

The resulting JWT can be verified in the standard way as described in another section.

=== Security, robustness and scalability of the SMS

The SMS is essentially a very simple memory cache with some security-oriented features.

The SMS implements only two APIs, one for writing and another for reading. Both are unauthenticated and do not require any previous registration. The server should be protected with standard DoS (Denial-of-Service) protection measures, like rate limiting. The APIs are intended for use by mobile apps and not by server-side applications.

When a Sender writes an object, the SMS stores the object in a memory cache and replies with an object ID. The object ID is a cryptographicaly secure random identifier for the object in the cache. Even if two write operations use the same object, the resulting object IDs are different and totally uncorrelated between them or with the object stored.

The cached object is automatically deleted from the cache when it is read by the Receiver or expires after a short period (the reference implementation of SMS uses 2 minutes). The rationale is that the object is written by the Sender immediately before a QR is displayed. The Receiver should scan the QR within 2 minutes, otherwise the Sender has to repeat the QR display again. Two minutes is more than enough for the whole process of scanning the QR by the Receiver.

The SMS is a pure memory cache and it does not use persistent storage for anything, not even for configuration data. It is stateless except for the two minutes that a given object resides in the cache.

For the above reasons, the SMS can be replicated as many times as needed in as many different physical locations as possible. The major problem to solve is to let Senders know the server addresses of those servers. In the case that Senders host one or more SMS server, they can use those. Citizens can not host SMSs so they have to use servers operated by somebody else. The easiest approach is that they use the SMS hosted by the Issuer of the credential they want to send to the Verifier. However, they can configure their application to use another server they trust more, for example operated by a public administration or other type of trusted organization.

== SafeIsland Verifiable Credentials

=== Data Model

The SafeIsland credential uses the standard https://www.w3.org/TR/vc-data-model[W3C Verifiable Credentials Data Model] for its representation, with some extensions to fit the requirements of this use case.

The specific Covid19 test data is encoded in the credentialSubject field of the VC. The following two figures represent the complete VC, where it has been divided in two parts to facilitate visualization.

---
.W3C Verifiable Credential and extensions
image::SafeIsland_VCSample.png[]
---

The figure above represents the VC with standard fields and some extensions.

1. The iss field (issuer in VC terminology), uses the DID method `elsi`, specific for legal persons and explained in a section below.

2. There is an extension to specify the blockchain network (or networks) where the VC can be verified. More precisely, the `issuedAt` field of `credentialSubject` specifies the networks where the identity for the legal person that issued the credential can be verified.
+
A legal person can have its `elsi` DID registered in one or more networks, and the same credential can be verified using any of those networks. The trust on the credential depends on the trust on the registration procedure of the identity of the signer. The Verifier entity can choose to verify the credential in whatever network is trusted to the Verifier.
+
This mechanism provides a lot of flexibility in interoperability schemes across networks. More details are described in the section on interoperability.

---
.Covid Credential inside the W3C VC
image::SafeIsland_VCDataModel.png[]
---

The figure above represents the specific Covid19 credential data.

=== ELSI: a novel DID Method for legal entities

The system supports several DID Methods, using the Universal Resolver to resolve each DID into a corresponding DID Document.
But the main DID Method used for legal persons, anchored into Red T, is *ELSI*: `did:elsi`.

The name ELSI stands for (**E**)TSI (**L**)egal person (**S**)emantics (**I**)dentifier, and corresponds to the information that should be included in the _organizationIdentifier_ attribute as described in the European Norm ETSI EN 319 412-1, related to digital signatures, peer entity authentication, data authentication as well as data confidentiality.

The structure of the DID (after the initial "did:elsi:" prefix) is:

- 3 character legal person identity type reference;
- 2 character ISO 3166 [2] country code;
- hyphen-minus "-" (0x2D (ASCII), U+002D (UTF-8)); and
- identifier (according to country and identity type reference).

For the three initial characters we support the following options:

- "VAT" for identification based on a national value added tax identification number.
- "LEI" for the https://www.gleif.org[Legal Entity Identifier]

Some examples of DIDs are the following:

.Example DIDs
[cols="2,4",options=header]
|=================================================================================
| Name                                           | DID                           
|BME Holding (www.bolsasymercados.es)            |*did:elsi:VATES-A83246314*     
|IN2 (www.ins.es)                                |*did:elsi:VATES-B60645900*     
|AENA (www.aena.es)                              |*did:elsi:VATES-A86212420*     
|Inter-American Development Bank (www.iadb.org)  |*did:elsi:LEIUS-VKU1UKDS9E7LYLMACP54*   
|=================================================================================

[[SplitVC]]
=== Splitting the VC into PII and non-PII for transmission

In this section we describe in detail how the SafeIsland VC is split into the PII and non-PII parts, so it can be transmitted with the mechanism detailed in the sections above.

---
.Example full VC
[source,json]
----
{
    "exp": 1608934564,
    "iat": 1608502564,
    "iss": "did:elsi:VATES-A86212420",
    "nbf": 1608502564,
    "sub": "46106508H",
    "vc": {
        "@context": [
            "https://www.w3.org/2018/credentials/v1",
            "https://alastria.github.io/identity/credentials/v1",
            "https://safeisland.org/.well-known/w3c-covid-test/v1"
        ],
        "type": [
            "VerifiableCredential",
            "AlastriaVerifiableCredential",
            "SafeIslandCovidTestResult"
        ],
        "credentialSubject": {
            "covidTestResult": {
                "analisys": {
                    "id": "unique ID of analysis",
                    "ver": "version number of analysis",
                    "date": "date when test sample taken",
                    "type": "type of test taken",
                    "result": "result of test"
                },
                "patient": {
                    "name": "surnames and name",
                    "idtype": "type of identifier",
                    "idnumber": "identifier number"
                },
                "lab": {
                    "name": "name of entity performing test",
                    "address": "postal address of entity",
                    "phone": "phone number of entity"
                },
                "comments": "additional data (non-PII)"
            },
            "issuedAt": "alastria.redt",
            "levelOfAssurance": 2
        }
    }
}
----

---

.Example VC: non-PII data for the SMS
[source,json]
----
{
    "exp": [[1]],
    "iat": [[2]],
    "iss": "did:elsi:VATES-A86212420",
    "nbf": [[3]],
    "sub": "[[4]]",
    "vc": {
        "@context": [
            "https://www.w3.org/2018/credentials/v1",
            "https://alastria.github.io/identity/credentials/v1",
            "https://safeisland.org/.well-known/w3c-covid-test/v1"
        ],
        "type": [
            "VerifiableCredential",
            "AlastriaVerifiableCredential",
            "SafeIslandCovidTestResult"
        ],
        "credentialSubject": {
            "covidTestResult": {
                "analisys": {
                    "id": "unique ID of analysis",
                    "ver": "version number of analysis",
                    "date": "[[5]]",
                    "type": "type of test taken",
                    "result": "result of test"
                },
                "patient": {
                    "name": "[[6]]",
                    "idtype": "type of identifier",
                    "idnumber": "[[4]]"
                },
                "lab": {
                    "name": "name of entity performing test",
                    "address": "postal address of entity",
                    "phone": "phone number of entity"
                },
                "comments": "additional data (non-PII)"
            },
            "issuedAt": "alastria.redt",
            "levelOfAssurance": 2
        }
    }
}
----

---

.Example VC: PII data for the QR
[source]
----
https://safeisland.hesusruiz.org/api/read/64945739540954873
KK4iGxfajtVMf8KsGdFuWD6F3xHnQcj5bj7DQgI_hDCHSXw7HpA1uMpGDyRK2LKIDgji1qixpmMj7oUUHsiEeQ
1608934564
1608502564
1608502564
46106508H
2020-03-09T22:18:26.625Z
----
---



== Interoperability

=== Other DID methods

=== Other blockchain networks

=== Different credential types

=== Data model

